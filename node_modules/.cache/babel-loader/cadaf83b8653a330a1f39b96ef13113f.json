{"remainingRequest":"/Users/sulliven/Desktop/vue/vue-cource/node_modules/babel-loader/lib/index.js!/Users/sulliven/Desktop/vue/vue-cource/src/router/index.js","dependencies":[{"path":"/Users/sulliven/Desktop/vue/vue-cource/src/router/index.js","mtime":1574857777779},{"path":"/Users/sulliven/Desktop/vue/vue-cource/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/sulliven/Desktop/vue/vue-cource/node_modules/babel-loader/lib/index.js","mtime":499162500000}],"contextDependencies":[],"result":["import \"core-js/modules/es6.function.name\";\nimport Vue from 'vue';\nimport Router from 'vue-router';\nimport routes from \"./router\";\nimport { setTitle } from '@/lib/util'; // Router作为一个插件需要use引入\n\nVue.use(Router); // export default new Router({\n//   routes: routes\n// })\n\nvar router = new Router({\n  routes: routes\n});\nvar HAS_LOGIN = true; // 全局前置守卫的设置\n\nrouter.beforeEach(function (to, from, next) {\n  to.meta && setTitle(to.meta.title);\n\n  if (to.name !== 'login') {\n    if (HAS_LOGIN) next(); // eslint-disable-next-line standard/object-curly-even-spacing\n    else next({\n        name: 'login'\n      });\n  } else {\n    if (HAS_LOGIN) next({\n      name: 'home'\n    });else next();\n  }\n}); // router.post('/getuserinfo', function (req, res, next) {\n//   console.log('请求成功')\n//   res.status(200).send({\n//     code: 200,\n//     data: {\n//       name: 'Sulliven'\n//     }\n//   })\n// })\n// router.beforeResolve() 和each一样  但是他是导航在被确认之前\n// 后置钩子 不能组织页面跳转 只能处理一些简单逻辑\n\nrouter.afterEach(function (to, from) {// logining = false 取消等待加载等\n}); // export default new Router({\n//   // 默认是hash模式 所以你看到的浏览器上默认是#\n//   //  这里我们更改模式为 history 无刷新页面的跳转 需要后段的支持\n//   // mode: 'history',\n//   routes\n// })\n// 完整的解析流程\n\n/**\n * 1.导航被触发\n * 2.在失活的组件 （即将要离开的页面组件）里调用离开守卫 beforeRouterLeave\n * 3. 调用全局的前置守卫 beforeEach\n * 4. 在重用的组件里调用 复用组件 beforeUpdate\n * 5.调用路由独享的守卫 beforeEnter\n * 6.解析一步路由组件\n * 7. 在激活的组件（即将进入的页面）里调用 beforeRouterEnter\n * 8.调用全局的解析守卫 beforeResolve\n * 9.导航被确认\n * 10. 调用全局的后置守卫 afterEach\n * 11.触发DOM的渲染\n * 12.用创建好的实例调用 beforeRouterEnter守卫里传给next的回掉函数\n */\n\nexport default router;",{"version":3,"sources":["/Users/sulliven/Desktop/vue/vue-cource/src/router/index.js"],"names":["Vue","Router","routes","setTitle","use","router","HAS_LOGIN","beforeEach","to","from","next","meta","title","name","afterEach"],"mappings":";AAAA,OAAOA,GAAP,MAAgB,KAAhB;AACA,OAAOC,MAAP,MAAmB,YAAnB;AACA,OAAOC,MAAP;AACA,SAASC,QAAT,QAAyB,YAAzB,C,CAEA;;AAEAH,GAAG,CAACI,GAAJ,CAAQH,MAAR,E,CACA;AACA;AACA;;AAEA,IAAMI,MAAM,GAAG,IAAIJ,MAAJ,CAAW;AACxBC,EAAAA,MAAM,EAANA;AADwB,CAAX,CAAf;AAIA,IAAMI,SAAS,GAAG,IAAlB,C,CACA;;AACAD,MAAM,CAACE,UAAP,CAAkB,UAACC,EAAD,EAAKC,IAAL,EAAWC,IAAX,EAAoB;AACpCF,EAAAA,EAAE,CAACG,IAAH,IAAWR,QAAQ,CAACK,EAAE,CAACG,IAAH,CAAQC,KAAT,CAAnB;;AACA,MAAIJ,EAAE,CAACK,IAAH,KAAY,OAAhB,EAAyB;AACvB,QAAIP,SAAJ,EAAeI,IAAI,GAAnB,CACA;AADA,SAEKA,IAAI,CAAC;AAAEG,QAAAA,IAAI,EAAE;AAAR,OAAD,CAAJ;AACN,GAJD,MAIO;AACL,QAAIP,SAAJ,EAAeI,IAAI,CAAC;AAAEG,MAAAA,IAAI,EAAE;AAAR,KAAD,CAAJ,CAAf,KACKH,IAAI;AACV;AACF,CAVD,E,CAWA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;;AACAL,MAAM,CAACS,SAAP,CAAiB,UAACN,EAAD,EAAKC,IAAL,EAAc,CAC7B;AACD,CAFD,E,CAIA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;;;;;;;;;;;;;;;AAcA,eAAeJ,MAAf","sourcesContent":["import Vue from 'vue'\nimport Router from 'vue-router'\nimport routes from './router'\nimport { setTitle } from '@/lib/util'\n\n// Router作为一个插件需要use引入\n\nVue.use(Router)\n// export default new Router({\n//   routes: routes\n// })\n\nconst router = new Router({\n  routes\n})\n\nconst HAS_LOGIN = true\n// 全局前置守卫的设置\nrouter.beforeEach((to, from, next) => {\n  to.meta && setTitle(to.meta.title)\n  if (to.name !== 'login') {\n    if (HAS_LOGIN) next()\n    // eslint-disable-next-line standard/object-curly-even-spacing\n    else next({ name: 'login' })\n  } else {\n    if (HAS_LOGIN) next({ name: 'home' })\n    else next()\n  }\n})\n// router.post('/getuserinfo', function (req, res, next) {\n//   console.log('请求成功')\n//   res.status(200).send({\n//     code: 200,\n//     data: {\n//       name: 'Sulliven'\n//     }\n//   })\n// })\n\n// router.beforeResolve() 和each一样  但是他是导航在被确认之前\n// 后置钩子 不能组织页面跳转 只能处理一些简单逻辑\nrouter.afterEach((to, from) => {\n  // logining = false 取消等待加载等\n})\n\n// export default new Router({\n//   // 默认是hash模式 所以你看到的浏览器上默认是#\n//   //  这里我们更改模式为 history 无刷新页面的跳转 需要后段的支持\n//   // mode: 'history',\n//   routes\n// })\n// 完整的解析流程\n/**\n * 1.导航被触发\n * 2.在失活的组件 （即将要离开的页面组件）里调用离开守卫 beforeRouterLeave\n * 3. 调用全局的前置守卫 beforeEach\n * 4. 在重用的组件里调用 复用组件 beforeUpdate\n * 5.调用路由独享的守卫 beforeEnter\n * 6.解析一步路由组件\n * 7. 在激活的组件（即将进入的页面）里调用 beforeRouterEnter\n * 8.调用全局的解析守卫 beforeResolve\n * 9.导航被确认\n * 10. 调用全局的后置守卫 afterEach\n * 11.触发DOM的渲染\n * 12.用创建好的实例调用 beforeRouterEnter守卫里传给next的回掉函数\n */\nexport default router\n"]}]}